
import sys
import os
import string as s
import json 
from pprint import *
from collections import defaultdict
from operator import getitem
from sqlalchemy import *
from datetime import *
import psycopg2
import dictgenerateupdate as gu
import json

class autoviv(dict):
    """Implementation of perl's autovivification feature."""
    def __getitem__(self, item):
        try:
            return dict.__getitem__(self, item)
        except KeyError:
            value = self[item] = type(self)()
            return value

# visittree=autoviv()

def tree(): return defaultdict(tree)

def dicts(t): return {k: dicts(t[k]) for k in t}

visittree=autoviv()
  
instructions=json.loads(open('vtmininginstructions.json').read())  
            
# print 'instructions', json.dumps(instructions)
            
db = create_engine("postgresql+psycopg2://li:pw@ip:host/dw")
db_con=db.connect()

selstr=instructions["allresults"]
ctstr=instructions["getcount"]
pagecol=instructions["pagecolumn"]
headerarray=instructions['headerarray']
uniquegrain=instructions['uniquegrain']
critpages=instructions['critpages']	
# critindlist=critpages['critindices'][pervalue]
# critpagelist=critpages['critpages'][pervalue]
textsearchinjects=instructions['textsearchinjects']
tabletodistinct=instructions['tabletodistinct']
arraytodistinct=instructions['arraytodistinct']
entrypoint=instructions['entrypoint']

pagecolindex=headerarray.index(pagecol)

addlpages=[]

for k in textsearchinjects.keys():
	tempstr='select distinct '+pagecol+' from '+ tabletodistinct+' where upper(pagenameclean) like \'%%'+textsearchinjects[k]+'%%\''
	print 'tempstr', tempstr
	
	inj=db_con.execute(tempstr)
	
	for row in inj:
		addlpages.append(row[0])

# print 'addlpages',addlpages

result=db_con.execute(selstr)

resultlen=db_con.execute(ctstr)

resultlen=[row for row in resultlen][0][0]

print 'resultlen',resultlen

def returnumarray(ary,headarry):
	temparry=[]
	for el in ary:
		if el in temparry==False:
			temparry.append(headarry.index(el))

	return temparry

# https://gist.github.com/hrldcpr/2012250

def createdistinctkeys(arraytodistinct,t): #FUNCTION TO STORE SETS OF DISTINCT VALUE COMBOS
											#THESE WILL BE USED TO GENERATE PRE-BUILT DICTIONARIES
											#SO THAT WE DONT WASTE CYCLES EVALUATING THEIR EXISTENCE
											#IN THE DICTIONARY WHEN WE CRAWL ROWS

	distinctstr=' '

	for el in arraytodistinct:
		distinctstr=distinctstr+' '+el

	distinctstr=distinctstr.strip(' ').replace(' ',',')

	selstr='select distinct '+distinctstr+' from '+ tabletodistinct 
	distresult=db_con.execute(selstr)

	distresultary=[]
	
	for row in  distresult:
		templist=[]
		for col in row:
			templist.append(col)
		distresultary.append(templist)
	
	for el in distresultary:  #THIS FUNCTION WORKS LIKE AUTOVIV,
								#BUT USED WITH ADD() FUNCTION WILL BUILD FROM ARBITRARY ARRAY
								#WE NEED THIS SO THAT USER CAN INPUT ARBITRARY LIST OF 
								#BREAKOUT VARIABLES WITHOUT RECODING 				
		temparry=[]
		for i in el:
			if not isinstance(i,basestring):
				i=str(i)
			temparry.append(i)
	
# 		print 'temparry',temparry
		
		t=gu.add(visittree,temparry)

def getentrypoint(evalstr):
	print 'entrypoint', entrypoint, type(entrypoint)
	print 'evalstr',evalstr, type(evalstr)
	entrypt=evalstr.index(entrypoint)
# 	try:	
# 		entrypt=evalstr.index(entrypoint)  #start from first page user enters test			
# 	except:
# 		e = sys.exc_info()[0]
# 		el=sys.exc_traceback.tb_lineno
# 
# 		print 'You have a session where entry page was not found'
# 		
# 		sys.exit()
	
	return entrypt
	
def	evalstring(evalstr,row):
	
		while evalstr.find(',,')>0:
			evalstr=evalstr.replace(',,',',')
	
		print 'evalstr',evalstr
		
		evalstr2=evalstr[1:len(evalstr)-1].split(',')
		evalstr2=[int(i) for i in evalstr2]
		firstentry=getentrypoint(evalstr2)

		print 'firstentry',firstentry

		pervalue=row[headerarray.index(critpages['pervalue'])]
		
		critindlist=critpages['critindices'][pervalue]	
		
		combinedlist=critindlist+addlpages
					
		strfordict=[]
		
		for i in evalstr2[firstentry:len(evalstr2)]:	
			if int(i) in combinedlist:
				strfordict.append(i)
		
		return strfordict
		
		
def createjson(t,instructions):
	print 'increatejson'
	prevbreakoutvartest=''
	
	pagelist=','

	prevuniquegraintest=''	
			
	rowct=0
	pagelist=''
		
	for row in result:
		uniquegraintest=''
		breakoutvartest=''
# 		print 'rowct',rowct
		
#  condition for current visitorid and visitnumber
		for col in uniquegrain: #store vals			
			uniquegraintest+=str(row[headerarray.index(col)])+'|'
		
		if prevuniquegraintest==uniquegraintest:
# 			print 'case1'
			pagelist+=','+str(row[pagecolindex])
# 			ALSO PUT TIMES
		elif rowct!=0: 
			print 'case2'
			distinctgrain=[]
			for col in arraytodistinct:
				tempstr1=row[headerarray.index(col)]
				if not isinstance(tempstr1,basestring):
					tempstr1=str(tempstr1)
				distinctgrain.append(tempstr1)
			print 'distinctgrain',distinctgrain
			pagelist+=','
			pathkey=evalstring(pagelist,row)
			print 'pathkey',pathkey
			gu.add(t,pathkey,'u',1,arraytodistinct,distinctgrain)
			pagelist=','+str(row[pagecolindex])
		else:
# 			print 'case3'
			pagelist=','+str(row[pagecolindex])
		
		if rowct==resultlen-1:
			print 'case4'
			distinctgrain=[]
			for col in arraytodistinct:
				tempstr1=row[headerarray.index(col)]
				if not isinstance(tempstr1,basestring):
					tempstr1=str(tempstr1)
				distinctgrain.append(tempstr1)
			print 'distinctgrain',distinctgrain
			pagelist+=','
			pathkey=evalstring(pagelist,row)
			print 'pathkey',pathkey
			gu.add(t,pathkey,'u',1,arraytodistinct,distinctgrain)

			
		prevuniquegraintest=uniquegraintest
		
		rowct+=1			

createjson(visittree,instructions)

print 'visittree',json.dumps(visittree)










