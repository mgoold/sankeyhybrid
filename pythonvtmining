
import sys
import os
import string as s
import json 
from pprint import *
from collections import defaultdict
from operator import getitem
from sqlalchemy import *
from datetime import *
import psycopg2
import dictgenerateupdate as gu
import json

class autoviv(dict):
    """Implementation of perl's autovivification feature."""
    def __getitem__(self, item):
        try:
            return dict.__getitem__(self, item)
        except KeyError:
            value = self[item] = type(self)()
            return value

# visittree=autoviv()

def tree(): return defaultdict(tree)

def dicts(t): return {k: dicts(t[k]) for k in t}

visittree=autoviv()
  
instructions=json.loads(open('vtmininginstructions.json').read())  
            
# print 'instructions', json.dumps(instructions)
            
db = create_engine("postgresql+psycopg2://tableau:LineGraphMinionChart@10.211.26.100:5439/ancestry")
db_con=db.connect()

selstr=instructions["allresults"]
ctstr=instructions["getcount"]
pagecol=instructions["pagecolumn"]
headerarray=instructions['headerarray']
uniquegrain=instructions['uniquegrain']
critpages=instructions['critpages']	
# critindlist=critpages['critindices'][pervalue]
# critpagelist=critpages['critpages'][pervalue]
textsearchinjects=instructions['textsearchinjects']
tabletodistinct=instructions['tabletodistinct']
arraytodistinct=instructions['arraytodistinct']
entrypoint=instructions['entrypoint']

pagecolindex=headerarray.index(pagecol)

addlpages=[]

for k in textsearchinjects.keys():
	tempstr='select distinct '+pagecol+' from '+ tabletodistinct+' where upper(pagenameclean) like \'%%'+textsearchinjects[k]+'%%\''
# 	print 'tempstr', tempstr
	
	inj=db_con.execute(tempstr)
	
	for row in inj:
		addlpages.append(row[0])

# print 'addlpages',addlpages
# print 'selstr', selstr

result=db_con.execute(selstr)

resultlen=db_con.execute(ctstr)

resultlen=[row for row in resultlen][0][0]

# print 'resultlen',resultlen

def returnumarray(ary,headarry):
	temparry=[]
	for el in ary:
		if el in temparry==False:
			temparry.append(headarry.index(el))

	return temparry

# https://gist.github.com/hrldcpr/2012250

def createdistinctkeys(arraytodistinct,t): #FUNCTION TO STORE SETS OF DISTINCT VALUE COMBOS
											#THESE WILL BE USED TO GENERATE PRE-BUILT DICTIONARIES
											#SO THAT WE DONT WASTE CYCLES EVALUATING THEIR EXISTENCE
											#IN THE DICTIONARY WHEN WE CRAWL ROWS

	distinctstr=' '

	for el in arraytodistinct:
		distinctstr=distinctstr+' '+el

	distinctstr=distinctstr.strip(' ').replace(' ',',')

# 	selstr='select distinct '+distinctstr+' from '+ tabletodistinct 
	distresult=db_con.execute(selstr)

	distresultary=[]
	
	for row in  distresult:
		templist=[]
		for col in row:
			templist.append(col)
		distresultary.append(templist)
	
	for el in distresultary:  #THIS FUNCTION WORKS LIKE AUTOVIV,
								#BUT USED WITH ADD() FUNCTION WILL BUILD FROM ARBITRARY ARRAY
								#WE NEED THIS SO THAT USER CAN INPUT ARBITRARY LIST OF 
								#BREAKOUT VARIABLES WITHOUT RECODING 				
		temparry=[]
		for i in el:
			if not isinstance(i,basestring):
				i=str(i)
			temparry.append(i)
	
# 		print 'temparry',temparry
		
		t=gu.add(visittree,temparry)

def getentrypoint(evalstr):
	entrypt=evalstr.index(entrypoint)
	
	return entrypt
	
def	evalstring(pervalue,evalstr,row):
	
		while evalstr.find(',,')>0:
			evalstr=evalstr.replace(',,',',')
	
# 		print 'evalstr',evalstr
		
		evalstr2=evalstr[1:len(evalstr)-1].split(',')
		evalstr2=[int(i) for i in evalstr2]
		firstentry=getentrypoint(evalstr2)

# 		print 'finalevalstr', evalstr2[firstentry:len(evalstr2)]

# 		print 'firstentry',firstentry
		
# 		print 'pervalue', pervalue
		
		critindlist=critpages['critindices'][pervalue]	
		
		combinedlist=critindlist+addlpages
		
# 		print 'combinedlist',combinedlist
					
		strfordict=[]
		
		for i in evalstr2[firstentry:len(evalstr2)]:	
			if int(i) in combinedlist:
				strfordict.append(i)
		
		return strfordict
		
		
def createjson(t,instructions):
# 	print 'increatejson'
	prevbreakoutvartest=''
	
	pagelist=','
	
	prevuniquegraintest=''	
			
	rowct=0
	pagelist=''
		
	for row in result:
		uniquegraintest=''
		breakoutvartest=''
# 		print 'createjsonrowct',rowct, row[pagecolindex]
		
#  condition for current visitorid and visitnumber
		for col in uniquegrain: #store vals			
			uniquegraintest+=str(row[headerarray.index(col)])+'|'
		
# 		print 'prevuniquegraintest,uniquegraintest',prevuniquegraintest,uniquegraintest
		
		if prevuniquegraintest==uniquegraintest:
# 			print 'case1'
			pagelist+=','+str(row[pagecolindex])
# 			ALSO PUT TIMES
		elif rowct!=0: 
# 			print 'case2'
# 			print 'distinctgrain',distinctgrain
			pagelist+=','
			pathkey=evalstring(pervalue,pagelist,row)
# 			print 'pathkey',pathkey
# 			print 'add arguments', arraytodistinct,distinctgrain
			gu.add(t,pathkey,'u',1,1,arraytodistinct,distinctgrain)
# 			print 'visittree',json.dumps(visittree)
			pagelist=','+str(row[pagecolindex])
		else:
# 			print 'case3'
			pagelist=','+str(row[pagecolindex])
		
		if rowct==resultlen-1:
# 			print 'case4'
# 			print 'distinctgrain',distinctgrain
			pagelist+=','
			pathkey=evalstring(pervalue,pagelist,row)
# 			print 'pathkey',pathkey
# 			print 'add arguments', arraytodistinct,distinctgrain			
			gu.add(t,pathkey,'u',1,1,arraytodistinct,distinctgrain)
# 			print 'visittree',json.dumps(visittree)
			
		distinctgrain=[]
		for col in arraytodistinct:
			tempstr1=row[headerarray.index(col)]
			if not isinstance(tempstr1,basestring):
				tempstr1=str(tempstr1)
			distinctgrain.append(tempstr1)
		
		pervalue=row[headerarray.index(critpages['pervalue'])]
			
		prevuniquegraintest=uniquegraintest
		
		rowct+=1			

createjson(visittree,instructions)
print 'visittree',json.dumps(visittree)










